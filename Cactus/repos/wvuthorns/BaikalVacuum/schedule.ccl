
# This schedule.ccl file was automatically generated by NRPy+.
#   You are advised against modifying it directly; instead
#   modify the Python code that generates it.

# First allocate storage for one timelevel of ADMBase gridfunctions, which is the
#    bare minimum needed by NRPy+. If another thorn (e.g., ADMBase itself) requests
#    more timelevels of storage, Cactus automatically allocates the maximum requested.
STORAGE: ADMBase::metric[1], ADMBase::curv[1], ADMBase::lapse[1], ADMBase::shift[1]

# Next allocate storage for all 3 gridfunction groups used in BaikalVacuum
STORAGE: evol_variables[3]     # Evolution variables
STORAGE: evol_variables_rhs[1] # Variables storing right-hand-sides
STORAGE: aux_variables[3]      # Diagnostics variables
STORAGE: auxevol_variables[1]  # Single-timelevel storage of variables needed for evolutions.

# The following scheduler is based on Lean/LeanBSSNMoL/schedule.ccl

schedule Banner_BaikalVacuum at STARTUP
{
  LANG: C
  OPTIONS: meta
} "Output ASCII art banner"

schedule RegisterSlicing_BaikalVacuum at STARTUP after Banner_BaikalVacuum
{
  LANG: C
  OPTIONS: meta
} "Register 3+1 slicing condition"

# This function registers the boundary conditions with PreSync.
schedule specify_Driver_BoundaryConditions_BaikalVacuum in Driver_BoundarySelect
{
  LANG: C
  OPTIONS: LEVEL
} "Register boundary conditions with PreSync"

schedule Symmetry_registration_oldCartGrid3D_BaikalVacuum at BASEGRID
{
  LANG: C
  OPTIONS: Global
} "Register symmetries, the CartGrid3D way."

schedule zero_rhss_BaikalVacuum at BASEGRID after Symmetry_registration_oldCartGrid3D_BaikalVacuum
{
  LANG: C
  WRITES: evol_variables_rhs(everywhere)
} "Idea from Lean: set all rhs functions to zero to prevent spurious nans"

schedule ADM_to_BSSN_BaikalVacuum at CCTK_INITIAL after ADMBase_PostInitial
{
  LANG: C
  OPTIONS: Local
  READS: ADMBase::metric,
         ADMBase::shift,
         ADMBase::curv,
         ADMBase::dtshift,
         ADMBase::lapse
  WRITES: evol_variables
  SYNC: evol_variables
} "Convert initial data into BSSN variables"

# This scheduled function shouldn't be necessary, as there are no BCs scheduled to be
# applied at this point.
schedule GROUP ApplyBCs as BaikalVacuum_ApplyBCs at CCTK_INITIAL after ADM_to_BSSN_BaikalVacuum
{
} "Apply boundary conditions"


# MoL: registration

schedule MoL_registration_BaikalVacuum in MoL_Register
{
  LANG: C
  OPTIONS: META
} "Register variables for MoL"


# MoL: compute RHSs, etc

if(FD_order == 4) {
  schedule Ricci_eval_BaikalVacuum_order_4 in MoL_CalcRHS as BaikalVacuum_Ricci before BaikalVacuum_RHS
  {
    LANG: C
    READS: hDD00GF, hDD01GF, hDD02GF, hDD11GF, hDD12GF, hDD22GF,
           lambdaU0GF, lambdaU1GF, lambdaU2GF
    WRITES: RbarDD00GF, RbarDD01GF, RbarDD02GF, RbarDD11GF, RbarDD12GF, RbarDD22GF
  } "MoL: Compute Ricci tensor, needed for BSSN RHSs, at finite-differencing order: 4"

  schedule rhs_eval_BaikalVacuum_order_4 in MoL_CalcRHS as BaikalVacuum_RHS after BaikalVacuum_Ricci
  {
    LANG: C
    READS: evol_variables(everywhere),
           auxevol_variables(interior)
    WRITES: evol_variables_rhs(interior)
  } "MoL: Evaluate BSSN RHSs, at finite-differencing order: 4"
}
if(FD_order == 6) {
  schedule Ricci_eval_BaikalVacuum_order_6 in MoL_CalcRHS as BaikalVacuum_Ricci before BaikalVacuum_RHS
  {
    LANG: C
    READS: hDD00GF, hDD01GF, hDD02GF, hDD11GF, hDD12GF, hDD22GF,
           lambdaU0GF, lambdaU1GF, lambdaU2GF
    WRITES: RbarDD00GF, RbarDD01GF, RbarDD02GF, RbarDD11GF, RbarDD12GF, RbarDD22GF
  } "MoL: Compute Ricci tensor, needed for BSSN RHSs, at finite-differencing order: 6"

  schedule rhs_eval_BaikalVacuum_order_6 in MoL_CalcRHS as BaikalVacuum_RHS after BaikalVacuum_Ricci
  {
    LANG: C
    READS: evol_variables(everywhere),
           auxevol_variables(interior)
    WRITES: evol_variables_rhs(interior)
  } "MoL: Evaluate BSSN RHSs, at finite-differencing order: 6"
}
if(FD_order == 8) {
  schedule Ricci_eval_BaikalVacuum_order_8 in MoL_CalcRHS as BaikalVacuum_Ricci before BaikalVacuum_RHS
  {
    LANG: C
    READS: hDD00GF, hDD01GF, hDD02GF, hDD11GF, hDD12GF, hDD22GF,
           lambdaU0GF, lambdaU1GF, lambdaU2GF
    WRITES: RbarDD00GF, RbarDD01GF, RbarDD02GF, RbarDD11GF, RbarDD12GF, RbarDD22GF
  } "MoL: Compute Ricci tensor, needed for BSSN RHSs, at finite-differencing order: 8"

  schedule rhs_eval_BaikalVacuum_order_8 in MoL_CalcRHS as BaikalVacuum_RHS after BaikalVacuum_Ricci
  {
    LANG: C
    READS: evol_variables(everywhere),
           auxevol_variables(interior)
    WRITES: evol_variables_rhs(interior)
  } "MoL: Evaluate BSSN RHSs, at finite-differencing order: 8"
}
schedule specify_NewRad_BoundaryConditions_parameters_BaikalVacuum in MoL_CalcRHS after BaikalVacuum_RHS
{
  LANG: C
  READS: evol_variables(everywhere)
  WRITES: evol_variables_rhs(boundary)
} "NewRad boundary conditions, scheduled right after RHS eval."

schedule floor_the_lapse_BaikalVacuum in MoL_PostStep before enforce_detgammahat_constraint_BaikalVacuum before BC_Update
{
  LANG: C
  READS: alphaGF(everywhere)
  WRITES: alphaGF(everywhere)
} "Set lapse = max(lapse_floor, lapse)"

schedule enforce_detgammahat_constraint_BaikalVacuum in MoL_PostStep before BC_Update
{
  LANG: C
  READS: hDD00GF, hDD01GF, hDD02GF, hDD11GF, hDD12GF, hDD22GF
  WRITES: hDD00GF(everywhere), hDD01GF(everywhere), hDD02GF(everywhere),
          hDD11GF(everywhere), hDD12GF(everywhere), hDD22GF(everywhere)
} "Enforce detgammabar = detgammahat (= 1 in Cartesian)"

# This schedule call is not required for PreSync but remains in the schedule for backward compatibility.
schedule specify_BoundaryConditions_evolved_gfs_BaikalVacuum in MoL_PostStep
{
  LANG: C
  OPTIONS: LEVEL
  SYNC: evol_variables
} "Apply boundary conditions and perform AMR+interprocessor synchronization"

# This schedule call is not required for PreSync but remains in the schedule for backward compatibility.
schedule GROUP ApplyBCs as BaikalVacuum_ApplyBCs in MoL_PostStep after specify_BoundaryConditions_evolved_gfs_BaikalVacuum
{
} "Group for applying boundary conditions"


# Next update ADM quantities

schedule BSSN_to_ADM_BaikalVacuum in MoL_PostStep after BaikalVacuum_ApplyBCs before ADMBase_SetADMVars
{
  LANG: C
  OPTIONS: Local
  READS: aDD00GF, aDD01GF, aDD02GF, aDD11GF, aDD12GF, aDD22GF, trKGF,
         cfGF, betU0GF, betU1GF, betU2GF, vetU0GF, vetU1GF, vetU2GF,
         hDD00GF, hDD01GF, hDD02GF, hDD11GF, hDD12GF, hDD22GF, alphaGF
  WRITES: ADMBase::metric(everywhere),
          ADMBase::shift(everywhere),
          ADMBase::curv(everywhere),
          ADMBase::dtshift(everywhere),
          ADMBase::lapse(everywhere)
} "Perform BSSN-to-ADM conversion. Useful for diagnostics."

# Compute Hamiltonian & momentum constraints

if(FD_order == 4) {
  schedule BSSN_constraints_BaikalVacuum_order_4 as BaikalVacuum_BSSN_constraints in MoL_PseudoEvolution
  {
    LANG: C
    OPTIONS: Local
    READS: aDD00GF, aDD01GF, aDD02GF, aDD11GF, aDD12GF, aDD22GF, trKGF,
           hDD00GF, hDD01GF, hDD02GF, hDD11GF, hDD12GF, hDD22GF,
           cfGF, lambdaU0GF, lambdaU1GF, lambdaU2GF
    WRITES: aux_variables
  } "Compute BSSN (Hamiltonian and momentum) constraints, at finite-differencing order: 4"
}

if(FD_order == 6) {
  schedule BSSN_constraints_BaikalVacuum_order_6 as BaikalVacuum_BSSN_constraints in MoL_PseudoEvolution
  {
    LANG: C
    OPTIONS: Local
    READS: aDD00GF, aDD01GF, aDD02GF, aDD11GF, aDD12GF, aDD22GF, trKGF,
           hDD00GF, hDD01GF, hDD02GF, hDD11GF, hDD12GF, hDD22GF,
           cfGF, lambdaU0GF, lambdaU1GF, lambdaU2GF
    WRITES: aux_variables
  } "Compute BSSN (Hamiltonian and momentum) constraints, at finite-differencing order: 6"
}

if(FD_order == 8) {
  schedule BSSN_constraints_BaikalVacuum_order_8 as BaikalVacuum_BSSN_constraints in MoL_PseudoEvolution
  {
    LANG: C
    OPTIONS: Local
    READS: aDD00GF, aDD01GF, aDD02GF, aDD11GF, aDD12GF, aDD22GF, trKGF,
           hDD00GF, hDD01GF, hDD02GF, hDD11GF, hDD12GF, hDD22GF,
           cfGF, lambdaU0GF, lambdaU1GF, lambdaU2GF
    WRITES: aux_variables
  } "Compute BSSN (Hamiltonian and momentum) constraints, at finite-differencing order: 8"
}

# This schedule call is not required for PreSync but remains in the schedule for backward compatibility.
schedule specify_BoundaryConditions_aux_gfs_BaikalVacuum in MoL_PseudoEvolution after BaikalVacuum_BSSN_constraints
{
  LANG: C
  OPTIONS: LEVEL
  SYNC: aux_variables
} "Enforce symmetry BCs in constraint computation"


# This schedule call is not required for PreSync but remains in the schedule for backward compatibility.
schedule GROUP ApplyBCs as BaikalVacuum_auxgfs_ApplyBCs in MoL_PseudoEvolution after specify_BoundaryConditions_aux_gfs_BaikalVacuum
{
} "Apply boundary conditions"

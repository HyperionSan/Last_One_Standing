
# This schedule.ccl file was automatically generated by NRPy+.
#   You are advised against modifying it directly; instead
#   modify the Python code that generates it.

# First allocate storage for one timelevel of ADMBase gridfunctions, which is the
#    bare minimum needed by NRPy+. If another thorn (e.g., ADMBase itself) requests
#    more timelevels of storage, Cactus automatically allocates the maximum requested.
STORAGE: ADMBase::metric[1], ADMBase::curv[1], ADMBase::lapse[1], ADMBase::shift[1]

# Next allocate storage for all 3 gridfunction groups used in Baikal
STORAGE: evol_variables[3]     # Evolution variables
STORAGE: evol_variables_rhs[1] # Variables storing right-hand-sides
STORAGE: aux_variables[3]      # Diagnostics variables
STORAGE: auxevol_variables[1]  # Single-timelevel storage of variables needed for evolutions.

# The following scheduler is based on Lean/LeanBSSNMoL/schedule.ccl

schedule Banner_Baikal at STARTUP
{
  LANG: C
  OPTIONS: meta
} "Output ASCII art banner"

schedule RegisterSlicing_Baikal at STARTUP after Banner_Baikal
{
  LANG: C
  OPTIONS: meta
} "Register 3+1 slicing condition"

# This function registers the boundary conditions with PreSync.
schedule specify_Driver_BoundaryConditions_Baikal in Driver_BoundarySelect
{
  LANG: C
  OPTIONS: LEVEL
} "Register boundary conditions with PreSync"

schedule Symmetry_registration_oldCartGrid3D_Baikal at BASEGRID
{
  LANG: C
  OPTIONS: Global
} "Register symmetries, the CartGrid3D way."

schedule zero_rhss_Baikal at BASEGRID after Symmetry_registration_oldCartGrid3D_Baikal
{
  LANG: C
  WRITES: evol_variables_rhs(everywhere)
} "Idea from Lean: set all rhs functions to zero to prevent spurious nans"

schedule ADM_to_BSSN_Baikal at CCTK_INITIAL after ADMBase_PostInitial
{
  LANG: C
  OPTIONS: Local
  READS: ADMBase::metric,
         ADMBase::shift,
         ADMBase::curv,
         ADMBase::dtshift,
         ADMBase::lapse
  WRITES: evol_variables
  SYNC: evol_variables
} "Convert initial data into BSSN variables"

# This scheduled function shouldn't be necessary, as there are no BCs scheduled to be
# applied at this point.
schedule GROUP ApplyBCs as Baikal_ApplyBCs at CCTK_INITIAL after ADM_to_BSSN_Baikal
{
} "Apply boundary conditions"


# MoL: registration

schedule MoL_registration_Baikal in MoL_Register
{
  LANG: C
  OPTIONS: META
} "Register variables for MoL"


# MoL: compute RHSs, etc

schedule T4DD_to_T4UU_Baikal in MoL_CalcRHS as Baikal_T4UU before BSSN_to_ADM_Baikal
{
  LANG: C
  READS: TmunuBase::stress_energy_scalar,
         TmunuBase::stress_energy_vector,
         TmunuBase::stress_energy_tensor,
         hDD00GF, hDD01GF, hDD02GF, hDD11GF, hDD12GF, hDD22GF,
         alphaGF, cfGF, vetU0GF, vetU1GF, vetU2GF
  WRITES: T4UU00GF(everywhere), T4UU01GF(everywhere), T4UU02GF(everywhere),
          T4UU03GF(everywhere), T4UU11GF(everywhere), T4UU12GF(everywhere),
          T4UU13GF(everywhere), T4UU22GF(everywhere), T4UU23GF(everywhere), T4UU33GF(everywhere)
} "MoL: Compute T4UU from T4DD (provided in eT?? from TmunuBase), needed for BSSN RHSs."

if(FD_order == 2) {
  schedule Ricci_eval_Baikal_order_2 in MoL_CalcRHS as Baikal_Ricci before Baikal_RHS
  {
    LANG: C
    READS: hDD00GF, hDD01GF, hDD02GF, hDD11GF, hDD12GF, hDD22GF,
           lambdaU0GF, lambdaU1GF, lambdaU2GF
    WRITES: RbarDD00GF, RbarDD01GF, RbarDD02GF, RbarDD11GF, RbarDD12GF, RbarDD22GF
  } "MoL: Compute Ricci tensor, needed for BSSN RHSs, at finite-differencing order: 2"

  schedule rhs_eval_Baikal_order_2 in MoL_CalcRHS as Baikal_RHS after Baikal_Ricci
  {
    LANG: C
    READS: evol_variables(everywhere),
           auxevol_variables(interior)
    WRITES: evol_variables_rhs(interior)
  } "MoL: Evaluate BSSN RHSs, at finite-differencing order: 2"
}
if(FD_order == 4) {
  schedule Ricci_eval_Baikal_order_4 in MoL_CalcRHS as Baikal_Ricci before Baikal_RHS
  {
    LANG: C
    READS: hDD00GF, hDD01GF, hDD02GF, hDD11GF, hDD12GF, hDD22GF,
           lambdaU0GF, lambdaU1GF, lambdaU2GF
    WRITES: RbarDD00GF, RbarDD01GF, RbarDD02GF, RbarDD11GF, RbarDD12GF, RbarDD22GF
  } "MoL: Compute Ricci tensor, needed for BSSN RHSs, at finite-differencing order: 4"

  schedule rhs_eval_Baikal_order_4 in MoL_CalcRHS as Baikal_RHS after Baikal_Ricci
  {
    LANG: C
    READS: evol_variables(everywhere),
           auxevol_variables(interior)
    WRITES: evol_variables_rhs(interior)
  } "MoL: Evaluate BSSN RHSs, at finite-differencing order: 4"
}
schedule specify_NewRad_BoundaryConditions_parameters_Baikal in MoL_CalcRHS after Baikal_RHS
{
  LANG: C
  READS: evol_variables(everywhere)
  WRITES: evol_variables_rhs(boundary)
} "NewRad boundary conditions, scheduled right after RHS eval."

schedule floor_the_lapse_Baikal in MoL_PostStep before enforce_detgammahat_constraint_Baikal before BC_Update
{
  LANG: C
  READS: alphaGF(everywhere)
  WRITES: alphaGF(everywhere)
} "Set lapse = max(lapse_floor, lapse)"

schedule enforce_detgammahat_constraint_Baikal in MoL_PostStep before BC_Update
{
  LANG: C
  READS: hDD00GF, hDD01GF, hDD02GF, hDD11GF, hDD12GF, hDD22GF
  WRITES: hDD00GF(everywhere), hDD01GF(everywhere), hDD02GF(everywhere),
          hDD11GF(everywhere), hDD12GF(everywhere), hDD22GF(everywhere)
} "Enforce detgammabar = detgammahat (= 1 in Cartesian)"

# This schedule call is not required for PreSync but remains in the schedule for backward compatibility.
schedule specify_BoundaryConditions_evolved_gfs_Baikal in MoL_PostStep
{
  LANG: C
  OPTIONS: LEVEL
  SYNC: evol_variables
} "Apply boundary conditions and perform AMR+interprocessor synchronization"

# This schedule call is not required for PreSync but remains in the schedule for backward compatibility.
schedule GROUP ApplyBCs as Baikal_ApplyBCs in MoL_PostStep after specify_BoundaryConditions_evolved_gfs_Baikal
{
} "Group for applying boundary conditions"


# Next update ADM quantities

schedule BSSN_to_ADM_Baikal in MoL_PostStep after Baikal_ApplyBCs before ADMBase_SetADMVars
{
  LANG: C
  OPTIONS: Local
  READS: aDD00GF, aDD01GF, aDD02GF, aDD11GF, aDD12GF, aDD22GF, trKGF,
         cfGF, betU0GF, betU1GF, betU2GF, vetU0GF, vetU1GF, vetU2GF,
         hDD00GF, hDD01GF, hDD02GF, hDD11GF, hDD12GF, hDD22GF, alphaGF
  WRITES: ADMBase::metric(everywhere),
          ADMBase::shift(everywhere),
          ADMBase::curv(everywhere),
          ADMBase::dtshift(everywhere),
          ADMBase::lapse(everywhere)
} "Perform BSSN-to-ADM conversion. Useful for diagnostics."

# Compute Hamiltonian & momentum constraints

schedule T4DD_to_T4UU_Baikal in MoL_PseudoEvolution before Baikal_BSSN_constraints
{
  LANG: C
  OPTIONS: Local
  READS: TmunuBase::stress_energy_scalar,
         TmunuBase::stress_energy_vector,
         TmunuBase::stress_energy_tensor,
         hDD00GF, hDD01GF,hDD02GF, hDD11GF, hDD12GF, hDD22GF,
         alphaGF, cfGF, vetU0GF, vetU1GF, vetU2GF
  WRITES: T4UU00GF(everywhere), T4UU01GF(everywhere), T4UU02GF(everywhere),
          T4UU03GF(everywhere), T4UU11GF(everywhere), T4UU12GF(everywhere),
          T4UU13GF(everywhere), T4UU22GF(everywhere), T4UU23GF(everywhere), T4UU33GF(everywhere)
} "MoL_PseudoEvolution: Compute T4UU from T4DD (provided in eT?? from TmunuBase), needed for BSSN constraints"

if(FD_order == 2) {
  schedule BSSN_constraints_Baikal_order_2 as Baikal_BSSN_constraints in MoL_PseudoEvolution
  {
    LANG: C
    OPTIONS: Local
    READS: aDD00GF, aDD01GF, aDD02GF, aDD11GF, aDD12GF, aDD22GF, trKGF,
           hDD00GF, hDD01GF, hDD02GF, hDD11GF, hDD12GF, hDD22GF,
           cfGF, lambdaU0GF, lambdaU1GF, lambdaU2GF
    READS: alphaGF, vetU0GF, vetU1GF, vetU2GF,
           T4UU00GF, T4UU01GF, T4UU02GF, T4UU03GF
    WRITES: aux_variables
  } "Compute BSSN (Hamiltonian and momentum) constraints, at finite-differencing order: 2"
}

if(FD_order == 4) {
  schedule BSSN_constraints_Baikal_order_4 as Baikal_BSSN_constraints in MoL_PseudoEvolution
  {
    LANG: C
    OPTIONS: Local
    READS: aDD00GF, aDD01GF, aDD02GF, aDD11GF, aDD12GF, aDD22GF, trKGF,
           hDD00GF, hDD01GF, hDD02GF, hDD11GF, hDD12GF, hDD22GF,
           cfGF, lambdaU0GF, lambdaU1GF, lambdaU2GF
    READS: alphaGF, vetU0GF, vetU1GF, vetU2GF,
           T4UU00GF, T4UU01GF, T4UU02GF, T4UU03GF
    WRITES: aux_variables
  } "Compute BSSN (Hamiltonian and momentum) constraints, at finite-differencing order: 4"
}

# This schedule call is not required for PreSync but remains in the schedule for backward compatibility.
schedule specify_BoundaryConditions_aux_gfs_Baikal in MoL_PseudoEvolution after Baikal_BSSN_constraints
{
  LANG: C
  OPTIONS: LEVEL
  SYNC: aux_variables
} "Enforce symmetry BCs in constraint computation"


schedule BSSN_to_ADM_Baikal in MoL_PseudoEvolution after specify_BoundaryConditions_aux_gfs_Baikal
{
  LANG: C
  OPTIONS: Local
  READS: aDD00GF, aDD01GF, aDD02GF, aDD11GF, aDD12GF, aDD22GF, trKGF,
         cfGF, betU0GF, betU1GF, betU2GF, vetU0GF, vetU1GF, vetU2GF,
         hDD00GF, hDD01GF, hDD02GF, hDD11GF, hDD12GF, hDD22GF, alphaGF
  WRITES: ADMBase::metric(everywhere),
          ADMBase::shift(everywhere),
          ADMBase::curv(everywhere),
          ADMBase::dtshift(everywhere),
          ADMBase::lapse(everywhere)
} "Perform BSSN-to-ADM conversion in MoL_PseudoEvolution. Needed for proper HydroBase integration."

# This schedule call is not required for PreSync but remains in the schedule for backward compatibility.
schedule GROUP ApplyBCs as Baikal_auxgfs_ApplyBCs in MoL_PseudoEvolution after specify_BoundaryConditions_aux_gfs_Baikal
{
} "Apply boundary conditions"
